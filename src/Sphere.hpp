#ifndef SPHERE
#define SPHERE

#include <vector>
#include <map>
#include <array>
#include <glm/glm.hpp>

/**
 *  A class that represents a Spherical drawable.
 *  Contains member functions for icosahedron generation and spherical division.
 */
class Sphere
{
    public:
        /**
         *  Initializes a Sphere generated using icosahedron division.
         *  @param radius - The desired radius of this spherical icosahedron.
         */
        Sphere(float radius);

        /**
         *  A basic copy operation on the Sphere object.
         *  Copying an object doesn't make sense, so we just delete it.
         */
        Sphere(const Sphere&) = delete;

        /**
         *  A basic move operation on the Sphere object.
         *  Moving an object doesn't make much sense, so we just delete it.
         */
        Sphere& operator=(const Sphere&) = delete;

        /** Deconstructor for the Sphere object. */
        ~Sphere() { };

        /** Retrieves the indices generated by this Sphere object. */
        std::vector<unsigned int> GetIndices();

        /** Retrieves the vertices generated by this Sphere object. */
        std::vector<float> GetVertices();

        /** Retrieves the normals generated by this Sphere object. */
        std::vector<float> GetNormals();

        /** Retrieves the vertices and normals generated by this Sphere object in OpenGL format. */
        std::vector<float> GetVertNorms();

        /**
         *  Returns this sphere's radius.
         *  @return The radius of the current sphere; defined at creation.
         */
        float GetRadius();

        /**
         *  Subdivides the icosahedron the given amount of times.
         *  @param iterations - The number of times you wish to divide this shape.
         */
        void Divide(int iterations);

        /** Divides the current icosahedron into more triangles. */
        void Subdivision();

        /** Generates normals for the current vertex array. */
        void GenerateNormals();

        /**
         *  Calculates the vertex normal values for the triangle provided.
         *  @param v1 - The first vertex in the triangle.
         *  @param v2 - The second vertex in the triangle.
         *  @param v3 - The third vertex in the triangle.
         *  @returns The vertex normal vectors.
         */
        std::array<std::array<float, 3>, 3> VertexNormal(std::array<float, 3> v1, std::array<float, 3> v2, std::array<float, 3> v3);

        /**
         *  Calculates the face normal values for the triangle provided.
         *  @param v1 - The first vertex in the triangle.
         *  @param v2 - The second vertex in the triangle.
         *  @param v3 - The third vertex in the triangle.
         *  @returns The face normal vector.
         */
        std::array<float, 3> FaceNormal(std::array<float, 3> v1, std::array<float, 3> v2, std::array<float, 3> v3);

        /**
         *  Normalizes the given vector into its unit form.
         *  @param vector - The vector to normalize.
         *  @returns The normalized version of the vector.
         */
        std::array<float, 3> Normalize(std::array<float, 3> vector);

        /**
         *  Adds the provided vertex to the list or returns its id.
         *  TODO: Add hashmap checking instead of sequential search.
         *  @param vertex - The vertex to be added to the end of the list.
         *  
         *  @return A pairing of the existing vertex's index and false, or size - 1 and true if it is added.
         */ // @param map    - The vertex pair map to be checked for existing index pairings. (removed for now)
        std::pair<unsigned int,bool> AddVertex( std::array<float,3> vertex/*, std::map<std::pair<unsigned int, unsigned int>, unsigned int> map */);

        /**
         *  Adds a new vertex to the back of the vertices list.
         *  @param one - The start vertex of the mid-point to be calculated.
         *  @param two - The end vertex of the mid-point to be calculated.
         *  @return The vertex corresponding to the middle point between one and two.
         */
        std::array<float,3> MidPoint
        (
            unsigned int one, 
            unsigned int two
        );

        /**
         *  Distributes a collision across the vertices from the provided vector.
         *  Physics assumptions: Assume direct collision, assume no fluid resistance/friction.
         *  @param vertex    - The point in space where the collision occurs.
         *  @param magnitude - The magnitude of the collision force.
         */
        void Collision( std::array<float,3> vertex, float magnitude);

        /** Finds the center point in 3D space of this sphere. */
        std::array<float,3> FindCenter();
        
    private:

        std::vector<std::array<float,3>       > vertices; // The list of unique vertices for the current shape.
        std::vector<std::array<float,3>       > normals;  // The list of normals corresponding to each vertex.
        std::vector<std::array<unsigned int,3>> indices;  // A list of the triangle indices formed from this shape's vertices.

        float radius;         // The spherical radius of this icosahedron.
        unsigned int counter; // Counter for unique keys
};

#endif